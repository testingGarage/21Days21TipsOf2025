# #21Days21Tips 2025 -- My Tips for Test Engineers
#### Drafting my 21 tips here to share as part of initiative from The Test Chat.  I'm sharing the tips for using the Git and GitHub to those who try it for the first time.  Do you have difficulty in implemeting and practicing these tips? Just reach out to me.  I will assist.

# 1. Day 1's Tip - Build a habit to Push at least one commit in a day.
- Create your account either on GitHub, Bitbucket, or GitLab
- Pick the publicly hosted test resources.
    - Test, Automate, Make Notes
    - Push your test artefacts
        - Use this as a placeholder to showcase your skills
        - This will be your professional portfolio
- Build and make it a **habit** to push atleast one meaningful outcome from your practice in a day.
    - No need of 70 hrs work in a week to do this.
    - The five meaningful push in a week shows your growth and learning.
    - Test Artefact is not confined to the code and compiled files alone.


- Installing Git [^1]
- Setting up Git [^2]

> git config --global user.name "name"

> git config --global user.email "my@email.com"

    make sure this email is configured in the GitHub account of yours. Profile -> Settings -> Access -> Emails.

> git --global user.name

> git --global user.email

[^1]: https://github.com/git-guides/install-git
[^2]: https://docs.github.com/en/get-started/git-basics/set-up-git

**Note**: Never use or push your organization's work into your personal account.


# 2. Day 2's Tip - Prioritize creating the ReadMe and .gitignore files.
Every repository you create, it should have these two files.
1. ReadMe.md
2. .gitignore

## ReadMe and Markdown
The ReadMe file type can be a simple plain text.  But, practice writing this file in Markdown. It gives a better readability and structuring.

Here are few resources you should refer
- What is Markdown? [^3]
- How to write ReadMe file? [^4]
- Markdown Cheat Sheet [^5]

[^3]: https://www.markdownguide.org/getting-started/
[^4]: https://www.makeareadme.com/
[^5]: https://www.markdownguide.org/cheat-sheet/

## Ignoring Files - .gitignore
There is no need to checkin all the files and folders into GitHub.  This can be accomplished by adding .gitingore file in the root of the repository.

This is must and useful to maintain the repository with what is needed.

Here are few resources you should refer:
- Why should on ignore certain files from checkin? [^6]
- .gitignore file templates. [^7]
- Reference to .gitignore file content. [^8]

[^6]: https://docs.github.com/en/get-started/git-basics/ignoring-files
[^7]: https://github.com/github/gitignore/tree/main
[^8]: https://www.toptal.com/developers/gitignore

You should be adding these two files as a must on creating a repository.  And, importantly it should be updated as the project and repository evolves.

# 3. Day 3's Tip - Create a repository and clone it. Commit changes. Push your commit.

To push the committed changes you need a remote repository on GitHub.  The same holds good for any other Git based code hosting cloud platform.

## Use this Approach to Push
Yet to make your first Push to the remote repository? Then,
1. For first clone the created repo to your local.
2. Create a branch locally and checkout to it.
3. Add file[s] and commit to this branch.
4. When pushing set the upstream to pointed to the created branch.

        git clone <remote_repo_url.git>
        git checkout -b dev
        git add <file_names>
        git commit -m "commit message"
        git push --set-upstream origin dev


Note: From next Push to the same branch, you can use,

           git push origin dev

 ## Avoid this Approach to Push

1. Initializing the local folder as git folder. 
2. Adding the files and committing the changes. 
3. Setting the origin to the remote repo URL. 
4. And, pushing the changes to the remote.

        git remote add origin <remote_repo_url.git>

### Why this should be avoided?
- Pointing the origin to remote repo URL, if gone wrong, it is a waste of time in troubleshooting.
- And, not a approach to be taken by one who is starting to use Git and GitHub for the first time.

# Day 4's Tip - Know the Branch or create one and commit to it. Do not work on the "main".
- Cloning a repository, know the Branch to which you have to commit.
- Know when the Branch to commit was created. If you see this branch exist for a long time, talk to your team and stakeholders why this branch is so long lived.

        How to quantify the "long"?  

        Your experiences will let you know that.  
        
        If not aware, have this thumb rule:
            a Branch living more than a sprint time in your setup, you need to ask about it to know if that is the right branch to use.

- If there is no branch yet, create one and commit to it.
- Keep an eye on number of Branch you are creating.   
    - Do you see too many branches? You need to ask about it and pick the right one.  Too many branches is an indication of could be something not going [or working] well.
- Do not work on the Main.
    - Say, you are fixing an automation run that is failing.
        - Fetch the master to your local.
        - Create a new Branch.
        - Make changes in this Branch to fix the code which is failing.
        - Commit this change and Push to remote.
        - Make a PR to review and Merge this change to Main.
            - Run the automation once your fix is Merged to the Main. It is the Test to your fix to know it is not broken and breaking anything else.
    - Doing so, you will have exact and precise reference to what you did.
        - Once Merged to Main, others can pull you code fix which is available in Main now.
    - Other team members can know what is your change from the PR along with Branch you have created.

Note that, I'm not saying -- do not have a copy of Master in local. I'm saying, do not commit to Main on remote repo for straight.  Instead use Branch and from there merge to Main.  Such practice varies and depends on team to team and within teams in an org.  Know how your setup runs.

# Day 5's Tip - The Branch name should tell what it is and who created. Branch name should be part of Code Review.
- The naming of a Branch is strategic and well practiced engineering.
- To illustrate this, look at the Branch name "draftingv1", where this tip is being pushed.
    - Does this name "draftingv1" tell you what the Branch is for?
    - In my opinion, that's a bad naming of a Branch.

## My Push Strategy for 21 Tips
- My strategy to post the 21Days21Tips for 2025 is,
    - Make 3 PRs.
    - Each PR will have 7 Tips.
    - Each PR will point to its respective Branch.
        -  That is, I will create 3 Branch. Each Branch will have 7 Tips.

## Strategic and Meaningful Branch Names
- In this approach, the better name for Branch is,
    1. **Week1Tips** 
    2. **Week2Tips** 
    3. **Week3Tips**

- I keep it short and no characters other than English alphabet letters and Number.
- I can understand in quick time what it means and what it has.
- It can help others to relate what it is when looked into it.
- My work is in meaningful blocks rather having all 21 Tips under one Branch.
    - A Branch having multiple commits and PRs will be energy, time and emotion draining if it has to be troubleshooted later.

            How do you quantify "multiple" here?  Talk to the reviewer of your code.  Talk to your Principal and Staff Engineer.  They will let know for your context.

## Renaming a Branch
- One can rename the **local Branch** using the below command.

        git branch -m oldBranchName newBranchName

- The above command takes -m and -M as an argument.
    - -m is for move (rename) a branch together with its config and reflog.
    - -M is for force move.
    - The meaning and purpose -m and -M are not same.
    - Explore on it when to use what.
- But, what actually happens is, we are moving the content to a new Branch
    - The old Branch will remain
    - We need to delete the old Branch in local and remote.
    - And, then set the upstream pointed to the new Branch.

            git branch --unset-upstream
            git branch --set-upstream-to=origin/newBranchName newBranchName

Note: I'm talking about renaming the Branch in local.  **The new renamed Branch has to be pushed to remote, before setting the upstream to i**t.

Do you see the pain and time wasted in renaming, deleting, unsetting and setting the upstream for a Branch?

It is better to practice the strategic and progressive engineering approach to name the Branch.

## Branch Name and Code Review
1. Do your Code Review talk about the Branch name?
2. Did you receive any feedback on Branch name from the Code Review?
3. The Branch name should be part of your Code Review.

Do you recall the purpose of Branch that you created 2 weeks back?

# Day 6's Tip - You can converse easily with Git on understanding its words and language.

I see, the hestitation arises due to unaware of language and its words.  Be it human to human communication, or human and other system communication.  Git is no exception to it. Understanding some of the often used words in Git is helpful to continue using it without getting intimidated.

## The Three States
Git has 3 main states in which the files can reside in.
1. Modified (unstaged)
2. Staged
3. Committed

## Working Directory (Unstaged)

- The local directory where the files are created and changes are made.
- The changes are not yet added to Index.
- The files are added to Index using the below command.

            git add fileNames
## Index (Staged)
- The files in this area are not yet committed
- On successful commit, 
    - It takes the contents of the Index and saves it as a permanent snapsot.
        - Creates a commit object which points to this snapshot.
    Updates the Head to point this commit.
- To commit the changes use the below command

            git commit -m "commit messages."
## HEAD
- It refers to the latest commit by default.
- It tells you, where are you at the present.
- Most of the time, HEAD points to a Branch.
    - When HEAD is not pointing to a Branch, it is a state called Detached HEAD.
        - This is not an error.
        - It is just saying, you are looking to a particular commit instead of a Branch.
        - In the next tip, we will look into this.


### Colors and Words on Git Terminal
- Head is represented by Cyan color
- Remote Branch is represented by Red color

![Git log showing the Head and Origin having the same commit snapshot](/resources/day6TipPic_gitLog_4.png "Git log showing the HEAD and Origin having the snap shot.")
HEAD and Remote Origin pointing to the same commit.

![Git showing the modified (unstaged) file is ready for moving to Index (Staging).](/resources/day6TipPic_gitLog_0.png "Git showing the modified (unstaged) file is ready for moving to Index (Staging).")
A file is modified and it is not yet staged.

![Git showing the file is added to Index and ready to Commit the changes](/resources/day6TipPic_gitLog_2.png "Modified file is added to Index (staged) and ready to commit.")
The modified file is staged.

![Git showing nothing to commit and Branch is ahead of the Remote Origin](/resources/day6TipPic_gitLog_3.png "Git showing nothing to commit and position of Head and Remote Origin.")
The staged file is committed and ready for Push.

![Git log showing the Branch and Remote Origin position are not pointing to the same commit.](/resources/day6TipPic_gitLog_1.png "Git log showing the Branch and Remote Origin not pointing to same commit.")
The HEAD is ahead of Remote Origin because the commit is not yet pushed to remote.

Understanding these words and its context will help you converse with Git and your team on code collaboration.
1. Unstaged
2. Index
3. Staged
4. Committed
5. HEAD
6. Detached HEAD
7. Commit Hash
8. Origin
9. Remote
10. Remote Origin
11. Repository
12. Merge Conflict
13. Rebase
14. Hooks
15. Cherry-pick
16. Stash
17. Reflog
18. Diff
19. Restore
20. Fork

Note: This is not the all. But, knowing the purpose of these words, will help you to start conversing confidently with Git.

# Day 7's Tip - Clone and Fork are two different approaches to work on a repository and make a PR for the merge.

If you have a GitHub account, more likely you could have also **forked** a repository.  You might also have watched someone's repository having a forked project.  What is this fork?  When should one use it? How is fork and clone are different?

## Clone and Fork

### Git Clone
- It is a Git command used to create a local copy of a remote repository.
- It duplicates the remote repository and its content to one's local machine.
    - When this happens, a Git folder is created in my local machine.

I use the Git Clone command when I want to contribute to a project.  This can be an existing project or a new project that is just created.

### Git Fork
- It is not a Git's command.
- Instead, it is a feature on GitHub and other code hosting platforms.
- For example, I can **fork** an existing GitHub repository to my GitHub's account.
    - Doing so, I see that is a forked repository.
    - On successful fork, this forked repository is not seen in my local machine.
        - Instead, this is seen on cloud space of my GitHub's account.


## When to use Clone and Fork?
- Git clone is used when I want to contribute to a project.
- Fork is used when I want to refer a repository for reference.
    - Also, I can use Fork when I want to add a new feature or an idea to an existing repository.
    - And, then submit this idea or feature for review for approval.
        - Here I'm working independently and not as a team.
            - For first, I will fork the repository.
            - Then, I will clone it to my local.
            - I start working on it to implement my thought (idea/feature/fix)
            - I push the changes to my forked repository.
            - Submit a PR to the original repository which is sent to maintainers of forked repository.
            - In this PR, I will mention what is the change I have made with context and needed details.
            - If you see, I'm doing all this because I do not have write access to that original repository

I will use **clone** when I have write access and wanting to contribute by collaborating.

I will use **fork** when I want to contribute to a repository for which I do not have write access.  Note that forking is not **mirroring** the repository.

When to mirror a repository? Explore on it.  In my so far experience, I have not mirroed any repository as a backup.  But, you should be knowing about it. Explore!


# Day 8's Tip - Have a Branch with name "**main**" and let that be your default Branch.

There is a purpose why the default branch name is "main".  Collaborators can relate to it in quick time most times when they fetch the latest and when makes a PR for merge.  Know the difference between the default branch and working branch in your context.  This will be of help to you.

## When "**main**" is Not the Default Branch

- If you look at the branch I created, it is **draftingv1**.
    - I pushed this branch to the upstream and kept it as a default Branch.
- When I want to make a PR and merge my code, to which Branch should I merge?
    - I should create a new Branch.
- But, tell me, is **draftingv1** a better name for the default branch which will be consumed by collaborators?

![On creating a repo, no branch is shown unless a push is made with a branch name.](/resources/day8TipPic_defaultBranchName.png "On creating a repo, no branch is shown unless a push is made with a branch name.")
Just created GitHub repo showing no branch.

## Minding the "main"
- It is not a necessity that default branch name should be "main".
- But, it is a helpful practice to avoid chaos and rework later in collaboration.
- Keeping the default branch name as "name" is a convention and to be respected for better collaboration.

## What Should I have Done?
Presuming, I just created a repo in GitHub and cloning it, I follow the below sequence of actions.

- On creating a GitHub repository abd cloning the repo I will be on the branch "**main**".
- Unless I specify a different branch,
        - The default branch in a repo is the base branch (**main**) for a new PR and code commits.
- I edit the ReadMe.md file and push it.
- This will show the "main" branch in GitHub.
    - The repo will have the ReadMe.md file with content that is pushed.
- Now, I create a new branch (**Week2Tips**) in local machine and I start committing to it.
    - Later I push the changes to origin under this new branch -- Week2Tips.
    - I see the new branch being pushed to remote repo.
    - Now, I see the update in the GitHub repo showing the recent push and new branch.
- Now, I can make a PR for this change and merge it to **main**.

![The recent push with new branch along with the branch "main" shown in the GitHub repo.](/resources/day8TipPic_newBranchName.png "The recent push with new branch shown in the GitHub repo for a PR on comparison with branch main.")

The GitHub repo showing the branches "main" and "Week2Tips".

Note: In this 21Days21Tipsof2025 repo you do not see "main" branch.  Instead you see "draftingv1" as a default branch for sake of learning -- the bad naming convention for a default branch.  That is the sole purpose of this Tip 8.


# Day 9's Tip - The .git folder information is the headlight when unsure of where you are and what you have in local and remote.

In the begining days, it is the common experience for a Test Engineer to be confused and unsure of what she or he has locally, and, what is in remote. It is a phase that all of us go through when we are collaborating, committing, pushing and making a PR.  This is very much evident when you want to pull a recent branch and look at a particular commit.

To help you and me in such case, the **.git** folder holds the information.  This folder is hidden by default in the file system of an OS.  Along with this, the below command helps you to identify if a branch is missing in local in comparison to origin.

        git remote show origin


## The Tree of .git

If you are Windows or Linux, use the command **tree** in the terminal switching to your local repo.  I use the below command on my Windows machine's terminal switching to .git folder,

        A:\21Days21TipsOf2025\tree /A /F .git

I see the below folder and file structure for .git in the terminal.

![The folder structure and files in .git folder.](/resources/day9TipPic_dotGitFolderTreeStructure.png "The folder structure and files in .git folder.")

This structure lets you know a lot.  For this Day 9's tip, lets focus on what is under the folder **refs**.

## The Branch and Refs

### Branch
- It is a placeholder for the commit you do.
- Each branch is a pointer to which I can switch.
- Visualize this,
    - The pointer is an address.
    - The address holds what you commit and push.
    - Later, the git will push what all you in a particular address to remote.
    - The branch helps me to classify and hold your work in a strategic way.
        - So that, I can move to it any point in time and view/rework on it if there is a need.

### Refs
- A **ref** is an indirect way of referring to a commit.
- It represents the branches and tags.

Under the .git folder, we see **refs** under the two folders,
1. logs
2. objects

Observe the data in these two refs folder.
- Look at the latest commit id in these two folders for the branch you are concerned.
- If the commit id present in /objects/refs/heads/<branch-name> is **not matching** with /logs/refs/heads/<branch-name> and /logs/refs/remotes/origin<branch-name>,
    - there is something missing.  

This simple **debugging** can be done with the help of,
- The last commit id hash that you got in your local branch in comparison to the same remote branch

Note: Refer to the above .git file structure for the refs folder under logs and objects.

## More into Refs

Use the below command to see what you have in refs,

        git remote show origin

This command returns the refs detail as this below.

![The refs detail returned from local working directory.](/resources/day9TipPic_gitRemoteShowOrigin.png "The refs detail returned from local working directory.")

Observe there what is under branches and refs in above pic.

1. The local branches show,
    - draftingv1
    - main
2. The local refs show,
    - Week2Tips
    - draftingv1

I do not have the **main** in local and as well in remote.
- But why do I see **main** when I'm supposed to pull?
- You can check the 21Days21TipsOf2025 repository on GitHub.
    - It does not have **main** branch.
    - Why do I see it?
    - Is this a problem with Git for not getting updated in local repo?
        - To know this, make a fresh **pull** of remote origin upon a PR merge to default branch (draftingv1 in this case)

## The Debugging Scope
Likewise, look at the local refs.
- It does not have **main**
- It has Week2Tips and draftingv1
    - This is the reality and truth on my machine and working directory
        - This is what we should consider primarily in debugging.
        - Is there a mismatch in my local and remote?
        - Am I missing to switch into right branch after the pull?
- I can fetch particular branch
- Also, I can fetch all branch
- After a fetch, you see local refs not having a branch name?
    - **This is one of the places where a Test Engineer fetching to local can miss **that one thing** which was pushed by other Test Engineer on a branch.**
        - Know the right remote branch.
            - On successful fetch, what do I see under local refs?
            - Do I see that paricular branch?
            - Further, I look at the latest commit ids.
            - This is **a heuristic to start exploring when I'm confused if I have it or not in my local**.


# Day 10's Tip - Reflog is the map in your hand for exploring the changes in your local.

When debugging we also look at the history.  And, Git is used used to track the changes.  I make use of the below in Git to learn the history.
1. ```git log```
2. ```git reflog```

The ```reflog``` means Reference Log.  It is a local traking mechanism which records,
- The updates to branch
- The HEAD reference
    - It tracks the move of HEAD, switching between branches, commits, merges, rebases and resets.

These details make the ```reflog``` as a useful debugging aid to revisit the actions and changes that I did locally.


## Reflog and History

![The successful Push shown with command git reflog.](/resources/day10TipPic_gitRefLog.png "The successful Push shown with command git reflog.")

The successful Push history returned with command ```git reflog```


![The all changes made locally shown with command git reflog show --all.](/resources/day10TipPic_gitRefLogShowAll.png "The all changes made locally shown with command git reflog show --all.")

All changes that are done made including the Push history returned with command ```git reflog show --all```

I can checkout to any HEAD and look into the details. For example, this command ```git checkout HEAD@{5}``` will switch me to the last 6th change (index) in the history of local.  I can look at the  files and its content at this point in time.


## Reflog and Diff

I can look at differenc between the two index on looking into the details of Reflog.

For example, here is the difference between these two index.

![The diff between the two index that I got from Reflog.](/resources/day10TipPic_gitDiffBtwHead.png "The diff between the two index that I got from Reflog.")

The differeces (or change) that has occured between the two index.  

I can debug the changes between the two indexes on referring to the outcome of command ```git reflog show --all```.  This helps me very much.

## Reflog and More

Reflog offers more which can be useful in debugging.  The ```reflog``` tracks entry with a timestamp.  This timestamp can be used to filter out reflog by time.

This ```git diff Head@{0} Head@{1.day.ago}``` returns the difference between the current Head to pevious day.

Explore more for the timed reflogs and the qualifiers to use.  It helps a lot over the time when comparing the two snapshots.


# Day 11's Tip - Knowing the difference is helpful; it helps in understanding the clarity.

As an engineer, I seek clarity in my work; so do you.  When you and I use Git to track the changes, we seek clarity consistently in knowing the changes.  ```git diff ``` comes to our help.  This is one of the commands we use often when using Git.

Learning to use ```git diff``` will help.

Here are some of the ways I do the ```diff```,
- ```git diff```
    - Shows if any difference in working area on comparing with staging area.
    - If nothing returned, then, there is no change in the working area on comparing with staging area.
        - **Note**:
            1. Make sure you are in the working area.
            2. If using VSCode make sure you save the changes and use ```git diff``` to see the difference.
- ```git diff --stat```
    - Returns the file name that is changed.
    - Returns the count of insertion and deletion.
- ```git diff -w```
    - ```-w``` ignores the whitespace changes
    - Do not use ```-w``` flag when working with langauge where whitespace and indentation is critical; a useful practice.
- ```git diff --staged```
    - The outcome shows the staged changes but not yet committed.
- ```git diff <commit-id-2> <commit-id-1>```
    - The differences between the two commits.
- ```git diff <commit-id>```
    - The difference between the current working area and the given commit.
- ```git diff --word-diff```
    - Shows the differenced word by word

Explore more on ```git diff``` here. [^9]
[^9]: https://git-scm.com/docs/git-diff


# Day 12's Tip - Reading and understanding the outcome of ```git diff``` should be a habit and a skill.

Reading and able to understand what I'm reading is a skill.  It has to be built as a habit.  Knowing the differences is key.  

As an engineer, when you work and add, and commit, you will cross a loop where you want to know the differences.  Be it within your artefacts or with the artefacts commit of others when collaborating.


## Reading the ```diff```

```git diff``` shows if any difference between working and staging area.  For example, the below pic shows the difference in file content between working and staging area.  Let us read this diff.

```

$ git diff
diff --git a/21Days21Tips_2025.md b/21Days21Tips_2025.md
index 10df5d9..31c6a32 100644
--- a/21Days21Tips_2025.md
+++ b/21Days21Tips_2025.md
@@ -537,6 +537,6 @@ As an engineer, when you work and add, and commit, you will cross a loop where y

 ## Reading the ```diff```

-```git diff``` shows if any difference between working area and staging area.
+```git diff``` shows if any difference between working and staging area.

```

![This is a outcome of git diff of working and staging area.](/resources/day12TipPic_readingGitDiff_1.png "This is a outcome of git diff of working and staging area.")

1. The file analyzed for the difference is '21Days21Tips_2025.md'.
2. Reading and understanding ```diff --git a/21Days21Tips_2025.md b/21Days21Tips_2025.md```
    1. For sake of better readability, the same file is represented visually as 'a' and 'b'.
        - a/21Days21Tips_2025.md  -- the older version
        - b/21Days21Tips_2025.md  -- the newer version
    2. The same file is picked in two versions, that is,
        - 10df5d9  -- the hash of file **before** the change.
        - 31c6a32  -- the hash of file **after** the change.
        - The above represents the hash-ids of the same file.
            - Note that, it is not the commit-id.
        - Git tracks files using **blobs**, which are stored by SHA-1 hash of their content.
3. ```index 10df5d9..31c6a32 100644```
    - This line tells that I'm comparing the blob ```10df5d9``` to ```31c6a32``` for the differences, while it is a same file.
    - ```index```, here it means hash index of the files that are being looked into and compared to know the difference.
        - This is my understanding so far on this!
    - ```100644``` tells about the file type and the file permission.
        - Per my understanding,
            - It is 1 and 00644
            - The first digit represents the **file type***
                - In Git,
                    - 1 is for normal file
                    - 2 is for Symlink
                    - 4 is for Git submodules
            - On exploring, I find Git uses,
                - ```040000``` for a directory
                - ```100644``` for a normal file
                - ```100755``` for an executable file
                - ```120000``` for a symbolic link
            - The next five digits represents the permission code for the file.

                | Octal Value | Who | Meaning
                |:------: | :-------:| :-------:|
                | 6 | Owner | Read and Write (4+2) |
                | 4 | Group | Read only (4) |
                | 4 | Others | Read only (4) |
                - So it is **rw-r--r--**
    - Refer to this information for more detail. [^10]


4. ```---``` idicates the old version of the file before the change.
5. ```+++``` indicates the new version of the file after the change.
6. ```-537,6``` indicates the change [removal] is observed between the line number 537 and spans to next 6 lines in the file ```a/21Days21Tips_2025.md```.
    - That is, between lines 537 to 542.
7. ```+537,6``` indicates the change [addition] is observed between the line number 537 and spans to next 6 lines in the file ```a/21Days21Tips_2025.md```.
    - Note that, the change is removal.
    - For this change which is saved, it shows ```+``` character.
    - Refer to the below pic for details. 
    ![The change is removal of word area and keeping the text as 'working and staging area'.](/resources/day12TipPic_readingGitDiff_2.png "The change is removal of word area and keeping the text as 'working and staging area'.")

8. The change in the file is as below.
    - The outcome of ```git diff```
    ![The change is removal of word area and keeping the text as 'working and staging area'.](/resources/day12TipPic_readingGitDiff_3.png "The change is removal of word area and keeping the text as 'working and staging area'.")

9. ```+``` indicates addition
10. ```-``` indicates removal
11. In this case, there is a removal ```-```.  By removal of a word, there is a change, so the, ```+```.

[^10]: https://unix.stackexchange.com/questions/193465/what-file-mode-is-a-symlink/193468#193468

With this, When you ```git diff```, you should be able to read and understand the diff!  Give the tries!  It will become simple eventually!


**Note**:
 - If the command from Git was ```diff --git b/21Days21Tips_2025.md a/21Days21Tips_2025.md```, then
    - The addition would have been first (which is in green color)
    - The deletion would have been second (which is in red color)


# Day 13's Tip - Using ```Gitk``` to know the Git is a visual learning.

In the last three tips we got to know about ```reflog``` and ```diff```.  With the first few earlier tips we got aware of basic and routine git commands.  All these were done through an interface - Command Line Interface.

Can I have a **visual look** of all these so that I understand better? Yes!

## Browsing the repository with ```Gitk```

To a beginner with Git, the Gitk is a useful utility to learn visually.  It is packaged and distributed with Git.  

In Gitk, you can see the log (history) visually. [^11] [^12] [^13] [^14]

Refer to the reference links 11, 12, 13 and 14.  It explains Gitk's feature and its user interface.

The Gitk can be opened with this command ```gitk``` from Git's bash.  If the Git is configured in path, then, we can open it in other termainals.

![The graphical interface of Gitk showing the commits visually with the diff.](/resources/day13TipPic_gitk_1.png "The graphical interface of Gitk showing the commits visually with the diff.")

Visual learning of a concept or a practice helps in a longer run. Use Gitk the way you explore to know the Git.

[^11]: https://lostechies.com/joshuaflanagan/2010/09/03/use-gitk-to-understand-git/
[^12]: https://lostechies.com/joshuaflanagan/2010/09/03/use-gitk-to-understand-git-merge-and-rebase/
[^13]: https://stackoverflow.com/questions/1570535/guide-to-understanding-gitk
[^14]: https://gitolite.com/gitk.html

# Day 14's Tip - Be comfortable to probe more using ```Gitk``` to learn the changes, and help your debugging. 

My first utility to aid in learning the changes in the repo is Gitk.  It will let me learn visually in quick time.  To do this, I will probe with below arguments.

## Gitk and Commands
- ```gitk```
- ```gitk --all```
- ```gitk branchName```
- ```gitk --author="authorName"```
- ```gitk commit-id```
- ```gitk --pathTo/baseTest.java```
- ```gitk draftingv1..Week2Tips```
    - Show the commit changes in branch Week2Tips that is not in draftingv1.
- ```gitk Head~3..Head```
    - Show the last three commit
- ```gitk --since="YYYY-MM-DD"```
- ```gitk --until="YYYY-MM-DD"```
- ```gitk --since="YYYY-MM-DD" --until="YYYY-MM-DD"```
- ```gitk --all --since="YYYY-MM-DD"```
- ```gitk --all --unitl="YYYY-MM-DD"```
- ```gitk --grep=wordToFind```
- ```gitk -n <number>```
    - Show the last 10 commits only.
- ```gitk --not brachName```
    - Show commits not reachable from branchName
- ```gitk branchName --not main```
    - Shows what is branchName and hides that of main as that is not reachable.
- ```gitk branchName --not main --not dev```
    - Shows what is in branchName and hides that of main and dev.
        - This is helpful when I want to see the unmerged commits.
        - For example, ```gitk hotfix --not myBranch```
            - This shows what is in hotfix branch and not in my branch.
- ```gitk --all -author"authorName" --since="1 day ago" --grep="gitk"```

Refer to this document for more details of gitk. [^15]

Refer to the below video understaning how to use the gitk.
- [![Gitk explained in the video by Michael Jones](/resources/day14TipPic_gitkThumbnailPic.png)](https://youtu.be/BuDYATyhl0U)


## Git and Debugging

With ```git log```, ```git reflog```, ```git diff``` and ```gitk``` we are on a springboard to jump start the debugging in our woring repo.

Refer to the above tips for ```log```, ```reflog```, ```diff``` and introduction of ```gitk```.

[^15]: https://git-scm.com/docs/gitk


# Day 15's Tip - The PR is a proposal for code merge. Don't be confused when you hear "Pull Request" and "Merge Request".

As a beginner, one can get confused with Push, Pull Request (PR) and Merge Request (MR).

The confusion can be and beyond this,
1. What does it mean?
2. When these terms are used -- Push, Pull Request and Merge Request?
3. How to use Push, PR and MR?
4. What should I make note of when Push, PR and MR?

Do you have any of this confusion?  I had this confusion when started using Git and GitHub.

**Both PR and MR is for merging a branch code with main branch through GUI of GitHub and GitLab** on successful code review and pipeline tests.  [^16] [^17] [^18] [^19]

Note that, when I say GUI here, it is the GUI of GitHub and GitLab. 



## Pull Request (PR)
- This term is used in GitHub, BitBucket, AzureDevops

## Merge Request (MR)
- This term is used in GitLab

[^16]: https://graphite.dev/guides/pull-request-vs-merge-request
[^17]: https://github.blog/developer-skills/github/beginners-guide-to-github-creating-a-pull-request/
[^18]: https://axolo.co/blog/p/pull-request-vs-merge-request
[^19]: https://docs.gitlab.com/user/project/merge_requests/creating_merge_requests/


